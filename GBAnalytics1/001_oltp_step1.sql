--generate the base temp table for all the operations

--CREATE DATABASE Resellers2ndHandStuffOLTP

SET NOCOUNT ON
Use Resellers2ndHandStuffOLTP

DROP TABLE IF EXISTS ##SC_TEMP_TABLE
CREATE TABLE ##SC_TEMP_TABLE
(
	val NVARCHAR(10)
)
INSERT INTO ##SC_TEMP_TABLE (val)
VALUES('b'), ('c'), ('d'), ('f'), ('g'), ('h'), ('j'), ('k'), ('m'), ('n'), ('p'), ('r'), ('s'), ('t'), ('v'), ('w'), ('y'), ('z'), ('bl'), ('br'), ('ch'), ('cl'), ('cr'), ('dr'), ('fl'), ('fr'), ('gh'), ('gl'), ('gn'), ('gr'), ('kn'), ('ph'), ('pl'), ('pr'), ('qu'), ('sc'), ('sh'), ('sk'), ('sl'), ('sm'), ('sn'), ('sp'), ('st'), ('th'), ('tr'), ('wh'), ('wr'), ('sch'), ('scr'), ('shm'), ('shr'), ('squ'), ('str'), ('thr')

DROP TABLE IF EXISTS ##SC_TEMP_TABLE2
CREATE TABLE ##SC_TEMP_TABLE2
(
	val NVARCHAR(10)
)
DECLARE @SCSubset SMALLINT = ABS(CHECKSUM(NEWID())) % (SELECT COUNT(*) FROM ##SC_TEMP_TABLE)
IF @SCSubSet < (SELECT COUNT(*) FROM ##SC_TEMP_TABLE) / 2
	SET @SCSubSet = (SELECT COUNT(*) FROM ##SC_TEMP_TABLE) / 2
INSERT INTO ##SC_TEMP_TABLE2
	SELECT TOP(@SCSubset) val FROM ##SC_TEMP_TABLE ORDER BY NEWID()

DROP TABLE IF EXISTS ##V_TEMP_TABLE
CREATE TABLE ##V_TEMP_TABLE
(
    val NVARCHAR(10)
)
INSERT INTO ##V_TEMP_TABLE (val)
VALUES('a'), ('e'), ('i'), ('o'), ('u'), ('ae'), ('ai'), ('ao'), ('au'), ('ea'), ('ee'), ('ei'), ('eu'), ('ia'), ('ie'), ('io'), ('oa'), ('oe'), ('oi'), ('oo'), ('ou'), ('ue'), ('ui')

DROP TABLE IF EXISTS ##V_TEMP_TABLE2
CREATE TABLE ##V_TEMP_TABLE2
(
	val NVARCHAR(10)
)
DECLARE @VSubset SMALLINT = ABS(CHECKSUM(NEWID())) % (SELECT COUNT(*) FROM ##V_TEMP_TABLE)
IF @VSubSet < (SELECT COUNT(*) FROM ##V_TEMP_TABLE) / 2
	SET @VSubSet = (SELECT COUNT(*) FROM ##V_TEMP_TABLE) / 2
INSERT INTO ##V_TEMP_TABLE2
	SELECT TOP(@VSubset) val FROM ##V_TEMP_TABLE ORDER BY NEWID()

DROP TABLE IF EXISTS ##EC_TEMP_TABLE
CREATE TABLE ##EC_TEMP_TABLE
(
    val NVARCHAR(10)
)
INSERT INTO ##EC_TEMP_TABLE (val)
VALUES('b'), ('c'), ('d'), ('f'), ('g'), ('l'), ('m'), ('n'), ('p'), ('r'), ('s'), ('t'), ('x'), ('z'), ('bt'), ('ch'), ('ck'), ('ct'), ('ft'), ('gh'), ('gn'), ('lb'), ('ld'), ('lf'), ('lk'), ('ll'), ('lm'), ('ln'), ('lp'), ('lt'), ('mb'), ('mn'), ('mp'), ('nk'), ('nk'), ('ng'), ('nt'), ('ph'), ('pt'), ('rb'), ('rc'), ('rd'), ('rf'), ('rg'), ('rk'), ('rl'), ('rm'), ('rn'), ('rp'), ('rt'), ('rv'), ('rz'), ('sh'), ('sk'), ('sp'), ('ss'), ('st'), ('zz'), ('lch'), ('lsh'), ('lth'), ('rch'), ('rsh'), ('rst'), ('rth'), ('sch'), ('tch')

DROP TABLE IF EXISTS ##EC_TEMP_TABLE2
CREATE TABLE ##EC_TEMP_TABLE2
(
	val NVARCHAR(10)
)
DECLARE @ECSubset SMALLINT = ABS(CHECKSUM(NEWID())) % (SELECT COUNT(*) FROM ##EC_TEMP_TABLE)
IF @ECSubSet < (SELECT COUNT(*) FROM ##EC_TEMP_TABLE) / 2
	SET @ECSubSet = (SELECT COUNT(*) FROM ##EC_TEMP_TABLE) / 2
INSERT INTO ##EC_TEMP_TABLE2
	SELECT TOP(@ECSubset) val FROM ##EC_TEMP_TABLE ORDER BY NEWID()

SELECT val
FROM ##SC_TEMP_TABLE
SELECT val
FROM ##V_TEMP_TABLE
SELECT val
FROM ##EC_TEMP_TABLE
SELECT val
FROM ##SC_TEMP_TABLE2
SELECT val
FROM ##V_TEMP_TABLE2
SELECT val
FROM ##EC_TEMP_TABLE2

DROP TABLE IF EXISTS ##TEMP_WORDS_TABLE
CREATE TABLE ##TEMP_WORDS_TABLE
(
	id INT UNIQUE,
    val NVARCHAR(100)
)
DELETE FROM ##TEMP_WORDS_TABLE
INSERT INTO ##TEMP_WORDS_TABLE
	SELECT TOP(83000) ROW_NUMBER() OVER (Order by sc.val), 
				        CONCAT(sc.val, v.val, ec.val) AS val2 FROM
						##SC_TEMP_TABLE sc CROSS JOIN
						##V_TEMP_TABLE v CROSS JOIN
						##EC_TEMP_TABLE ec

DROP INDEX IF EXISTS CCI_TEMP_WORDS_TABLE ON ##TEMP_WORDS_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_WORDS_TABLE
ON ##TEMP_WORDS_TABLE(id)
SELECT * FROM ##TEMP_WORDS_TABLE ORDER BY id
SELECT TOP(1) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID();

DROP TABLE IF EXISTS ##TEMP_SINGLE_INT_TABLE
CREATE TABLE ##TEMP_SINGLE_INT_TABLE
(
	id INT UNIQUE,
	val INT
)
INSERT INTO ##TEMP_SINGLE_INT_TABLE(id, val) VALUES(1, '0'), (2, '1'), (3, '2'), (4, '3'), (5, '4'), (6, '5'), (7, '6'), (8, '7'), (9, '8'), (10, '9')
SELECT val FROM ##TEMP_SINGLE_INT_TABLE ORDER BY NEWID();
SELECT COUNT(*) FROM ##TEMP_SINGLE_INT_TABLE

--SELECT CONCAT(q1.val, q2.val) FROM ##TEMP_SINGLE_INT_TABLE q1
--CROSS JOIN ##TEMP_SINGLE_INT_TABLE q2

DROP TABLE IF EXISTS ##TEMP_INT_TABLE
CREATE TABLE ##TEMP_INT_TABLE
(
	id INT,
	val INT,
	num_digits INT
)
--use temp table so that the ordering of the rows will be only on new zip data and not the source table TEMP_INT_TABLE
--note to self:  isn't there a better way of doing this..?
DECLARE @tempIntTable TABLE(id INT, val INT, num_digits INT)
INSERT INTO @tempIntTable(id, val, num_digits)
	SELECT ROW_NUMBER() OVER (ORDER BY q1.val),
	CONCAT(q1.val, q2.val, q3.val, q4.val, q5.val) as val
	,5 as num_digits
	FROM ##TEMP_SINGLE_INT_TABLE q1
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q2
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q3
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q4
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q5
	where q1.val <> 0
    
	UNION ALL
	SELECT ROW_NUMBER() OVER (ORDER BY q1.val),
	CONCAT(q1.val, q2.val, q3.val, q4.val) as val
	,4 as num_digits
	FROM ##TEMP_SINGLE_INT_TABLE q1
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q2
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q3
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q4
	WHERE q1.val <> 0
    
	UNION ALL
	SELECT ROW_NUMBER() OVER (ORDER BY q1.val),
	CONCAT(q1.val, q2.val, q3.val) as val
	,3 as num_digits
	FROM ##TEMP_SINGLE_INT_TABLE q1
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q2
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q3
	WHERE q1.val <> 0
    
	UNION ALL
	SELECT ROW_NUMBER() OVER (ORDER BY q1.val),
	CONCAT(q1.val, q2.val) as val
	,2 as num_digits
	FROM ##TEMP_SINGLE_INT_TABLE q1
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE q2
	WHERE q1.val <> 0

	UNION ALL
	SELECT ROW_NUMBER() OVER (ORDER BY q1.val),
	q1.val as val
	,1 as num_digits
	FROM ##TEMP_SINGLE_INT_TABLE q1
	WHERE q1.val <> 0
SELECT * FROM ##TEMP_INT_TABLE where num_digits=1

INSERT INTO ##TEMP_INT_TABLE(id, val, num_digits)
	SELECT ROW_NUMBER() OVER (Order by NEWID()), val, num_digits FROM @tempIntTable
DROP INDEX IF EXISTS CCI_TEMP_INT_TABLE ON ##TEMP_INT_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_INT_TABLE
ON ##TEMP_INT_TABLE(id)
SELECT TOP(1000) * FROM ##TEMP_INT_TABLE ORDER BY NEWID()


DROP TABLE IF EXISTS ##TEMP_FLOAT_TABLE
CREATE TABLE ##TEMP_FLOAT_TABLE
(
	id INT UNIQUE,
	val FLOAT,
	num_digits INT
)
INSERT INTO ##TEMP_FLOAT_TABLE(id, val, num_digits)
	SELECT ROW_NUMBER() OVER (Order by subq.val), CONCAT(subq.val, '.', fpart.val), subq.num_digits FROM 
	(SELECT val, num_digits FROM ##TEMP_INT_TABLE WHERE val <= 1000) subq
	CROSS JOIN ##TEMP_SINGLE_INT_TABLE fpart
	WHERE fpart.val = 0 OR fpart.val = 3 OR fpart.val = 7
	
SELECT * FROM ##TEMP_FLOAT_TABLE 
--WHERE num_digits >= 2 AND num_digits <= 4
ORDER BY id
DROP INDEX IF EXISTS CCI_TEMP_FLOAT_TABLE ON ##TEMP_FLOAT_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_FLOAT_TABLE
ON ##TEMP_FLOAT_TABLE(id)

--TRUNCATE TABLE ##TEMP_PHONE_NO_TABLE
DROP TABLE IF EXISTS ##TEMP_PHONE_NO_TABLE
CREATE TABLE ##TEMP_PHONE_NO_TABLE
(
	id INT UNIQUE,
	phone_no NVARCHAR(25),
	country_code NVARCHAR(5)
)
--CROSS APPLY is useful when there isnt an obvious JOIN condition
INSERT INTO ##TEMP_PHONE_NO_TABLE(id, phone_no, country_code)
	SELECT ROW_NUMBER() OVER (Order by subq.val), CONCAT(subq.val, '-', subq2.val, '-', subq3.val), '+05'
	FROM ##TEMP_INT_TABLE subq
	CROSS APPLY 
	(SELECT TOP(7) val FROM ##TEMP_INT_TABLE WHERE num_digits=3 ORDER BY NEWID()) subq2
	CROSS APPLY
	(SELECT TOP(5) val FROM ##TEMP_INT_TABLE WHERE num_digits=4 ORDER BY NEWID()) subq3
	WHERE num_digits=3
	ORDER BY NEWID()
SELECT TOP(10000) * FROM ##TEMP_PHONE_NO_TABLE
DROP INDEX IF EXISTS CCI_TEMP_PHONE_NO_TABLE ON ##TEMP_PHONE_NO_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_PHONE_NO_TABLE
ON ##TEMP_PHONE_NO_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_EMAIL_TABLE
CREATE TABLE ##TEMP_EMAIL_TABLE
(
	id INT UNIQUE,
	email NVARCHAR(75)
)
INSERT INTO ##TEMP_EMAIL_TABLE(id, email)
	SELECT ROW_NUMBER() OVER (Order By subq.val), CONCAT(subq.val, '@', subq2.val, '.com')
	FROM ##TEMP_WORDS_TABLE subq
	CROSS APPLY
	(SELECT TOP(25) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID()) subq2
--create enough variability in the cross apply above, then delete all but 250000
DELETE FROM ##TEMP_EMAIL_TABLE 
WHERE id > 250000
SELECT * FROM ##TEMP_EMAIL_TABLE
SELECT COUNT(*) FROM ##TEMP_EMAIL_TABLE
DROP INDEX IF EXISTS CCI_TEMP_EMAIL_TABLE ON ##TEMP_EMAIL_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_EMAIL_TABLE
ON ##TEMP_EMAIL_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_STATE_TABLE
CREATE TABLE ##TEMP_STATE_TABLE
(
	id INT UNIQUE,
	state_val NVARCHAR(50)
)
INSERT INTO ##TEMP_STATE_TABLE(id, state_val)
	SELECT TOP(50) ROW_NUMBER() OVER (Order By subq.val), CONCAT(subq.val, subq2.val)
	FROM ##TEMP_WORDS_TABLE subq
	CROSS APPLY
	(SELECT TOP(10) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID()) subq2
SELECT * FROM ##TEMP_STATE_TABLE
DROP INDEX IF EXISTS CCI_TEMP_STATE_TABLE ON ##TEMP_STATE_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_STATE_TABLE
ON ##TEMP_STATE_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_CITY_TABLE
CREATE TABLE ##TEMP_CITY_TABLE
(
	id INT UNIQUE,
	city NVARCHAR(50)
)
INSERT INTO ##TEMP_CITY_TABLE(id, city)
	SELECT ROW_NUMBER() OVER (Order by NEWID()), CONCAT(subq.val, subq2.val, ' ', subq3.val)
	FROM ##TEMP_WORDS_TABLE subq
	CROSS APPLY
	(SELECT TOP(10) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID()) subq2
	CROSS APPLY 
	(SELECT TOP(200) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID()) subq3
	WHERE subq.id < 100
--SELECT * FROM ##TEMP_CITY_TABLE
SELECT COUNT(*) AS cityCnt FROM ##TEMP_CITY_TABLE

DROP INDEX IF EXISTS CCI_TEMP_CITY_TABLE ON ##TEMP_CITY_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_CITY_TABLE
ON ##TEMP_CITY_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_ZIP_TABLE
CREATE TABLE ##TEMP_ZIP_TABLE
(
	id INT UNIQUE,
	zip_code INT
)
--use temp table so that the ordering of the rows will be only on new zip data and not the source table TEMP_INT_TABLE
--note to self:  isn't there a better way of doing this..?
DECLARE @tempZipTable TABLE(id INT, zip_code INT)
INSERT INTO @tempZipTable(id, zip_code)
	SELECT TOP(30000) 0, val FROM ##TEMP_INT_TABLE WHERE num_digits=5 ORDER BY NEWID() 

INSERT INTO ##TEMP_ZIP_TABLE(id, zip_code)
	SELECT ROW_NUMBER() OVER (Order by NEWID()), zip_code FROM @tempZipTable

SELECT * FROM ##TEMP_ZIP_TABLE ORDER By id
DROP INDEX IF EXISTS CCI_TEMP_ZIP_TABLE ON ##TEMP_ZIP_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_ZIP_TABLE
ON ##TEMP_ZIP_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_DATE_TABLE
CREATE TABLE ##TEMP_DATE_TABLE
(
	id INT UNIQUE,
	val DATE
)
INSERT INTO ##TEMP_DATE_TABLE(id, val)
	SELECT TOP(150000) ROW_NUMBER() OVER (Order By NEWID()), DATEADD(DAY, 
  	                                                    RAND(CHECKSUM(NEWID())) * (1 + DATEDIFF(DAY,
																						   '01/01/2016',
																						   '08/31/2025'
																					      )
																			),
   													   '01/01/2016')
	FROM ##TEMP_INT_TABLE
	WHERE num_digits > 3
SELECT TOP(5000) * FROM ##TEMP_DATE_TABLE ORDER BY id
DROP INDEX IF EXISTS CCI_TEMP_DATE_TABLE ON ##TEMP_DATE_TABLE
CREATE CLUSTERED INDEX CCI_TEMP_DATE_TABLE
ON ##TEMP_DATE_TABLE(id)

DROP TABLE IF EXISTS ##TEMP_DATETIME_TABLE
CREATE TABLE ##TEMP_DATETIME_TABLE
(
	id INT UNIQUE,
	val DATETIME
)
INSERT INTO ##TEMP_DATETIME_TABLE(id, val)
	SELECT TOP(150000) ROW_NUMBER() OVER (Order By NEWID()), DATEADD(HOUR, CHECKSUM(NEWID()) % 24, CAST(val as DATETIME))
	FROM ##TEMP_DATE_TABLE
SELECT * FROM ##TEMP_DATETIME_TABLE ORDER BY id

DROP TABLE IF EXISTS ##TEMP_BOOL_TABLE
CREATE TABLE ##TEMP_BOOL_TABLE
(
	id INT UNIQUE,
	val BIT
)
DECLARE @tempBoolTable TABLE(id INT, val BIT)
INSERT INTO @tempBoolTable(id, val) VALUES(0, 0), (1, 1), (2, 0), (3, 1), (4, 0), (5, 1), (6, 0), (7, 1), (8, 0), (9, 1)

INSERT INTO ##TEMP_BOOL_TABLE(id, val)
	SELECT ROW_NUMBER() OVER (Order by NEWID()), subq.val
	FROM (SELECT id, val FROM @tempBoolTable) subq
	CROSS JOIN (SELECT id, val FROM @tempBoolTable) subq2 
	CROSS JOIN (SELECT id, val FROM @tempBoolTable) subq3 
	CROSS JOIN (SELECT id, val FROM @tempBoolTable) subq4 

--reuse tempBoolTable to correct the numbering of the ids
DELETE FROM @tempBoolTable
INSERT INTO @tempBoolTable(id, val) 
	SELECT ROW_NUMBER() OVER (Order By id), val
	FROM ##TEMP_BOOL_TABLE
DELETE FROM ##TEMP_BOOL_TABLE
INSERT INTO ##TEMP_BOOL_TABLE(id, val)
	SELECT * from @tempBoolTable
SELECT * FROM ##TEMP_BOOL_TABLE ORDER BY id


DROP TABLE IF EXISTS ##TEMP_URL_TABLE
CREATE TABLE ##TEMP_URL_TABLE
(
	id INT UNIQUE,
	url NVARCHAR(100)
)
--CROSS APPLY is useful when there isnt an obvious JOIN condition
INSERT INTO ##TEMP_URL_TABLE(id, url)
	SELECT ROW_NUMBER() OVER (Order by subq.val), CONCAT('https://www.', subq.val, '.com', '/', subq2.val)
	FROM ##TEMP_WORDS_TABLE subq
	CROSS APPLY 
	(SELECT TOP(3) val FROM ##TEMP_WORDS_TABLE ORDER BY NEWID()) subq2
	ORDER BY id
SELECT  * FROM ##TEMP_URL_TABLE ORDER by id

DROP TABLE IF EXISTS ##TEMP_BUDGET_CATG_TABLE
CREATE TABLE ##TEMP_BUDGET_CATG_TABLE
(
	id INT UNIQUE,
	val NVARCHAR(50)
)
INSERT INTO ##TEMP_BUDGET_CATG_TABLE VALUES(1, 'Cheap'), (2, 'Affordable'), (3, 'Good'), (4, 'Fine')
DROP TABLE IF EXISTS ##TEMP_KIND_OF_BUSINESS_CATG_TABLE
CREATE TABLE ##TEMP_KIND_OF_BUSINESS_CATG_TABLE
(
	id INT UNIQUE,
	val NVARCHAR(50)
)
INSERT INTO ##TEMP_KIND_OF_BUSINESS_CATG_TABLE VALUES (1, 'Mens clothing'), (2, 'Kids clothing'), (3, 'Womens clothing'), (4, 'Consumer Electronics'), (5, 'Comic books'),
                                                      (6, 'Used movies'), (7, 'Vitamins'), (8, 'Toys'), (9, 'Earths organics goods'), (10, 'Used books and periodicals')
--todo:  would be nice to create ##TEMP_PRODUCT_TYPE like shirt, pants, shorts, etc, but then would have to correlate them to the business category
--       so this would complicated the data generation, so consider this for later
SELECT COUNT(*) AS NumCities FROM ##TEMP_CITY_TABLE
SELECT COUNT(*) AS NumEmails FROM ##TEMP_EMAIL_TABLE
SELECT COUNT(*) AS NumFloats FROM ##TEMP_FLOAT_TABLE
SELECT COUNT(*) AS NumInts FROM ##TEMP_INT_TABLE
SELECT COUNT(*) AS NumPhones FROM ##TEMP_PHONE_NO_TABLE
SELECT COUNT(*) AS NumSingleInts FROM ##TEMP_SINGLE_INT_TABLE
SELECT COUNT(*) AS NumStates FROM ##TEMP_STATE_TABLE
SELECT COUNT(*) AS NumTempWords FROM ##TEMP_WORDS_TABLE
SELECT COUNT(*) AS NumZips FROM ##TEMP_ZIP_TABLE
SELECT COUNT(*) AS NumDates FROM ##TEMP_DATE_TABLE
SELECT COUNT(*) AS NumDatetimes FROM ##TEMP_DATETIME_TABLE
SELECT COUNT(*) AS NumBools FROM ##TEMP_BOOL_TABLE
SELECT COUNT(*) AS NumUrls FROM ##TEMP_URL_TABLE
SELECT COUNT(*) AS NumBudgetCatgs FROM ##TEMP_BUDGET_CATG_TABLE
SELECT COUNT(*) AS NumKindOfBusinessCatgs FROM ##TEMP_KIND_OF_BUSINESS_CATG_TABLE

--todo: 6/11/25 maybe rewrite all of the code below and 
--create a multi-line value function or an inline function (if no addl operations needed)
--example of just concatting across tables based on an id to build the rows
/*SELECT subq.id, subq.val, subq2.val, subq3.val, subq4.val
FROM ##TEMP_WORDS_TABLE subq
JOIN ##TEMP_INT_TABLE subq2 ON subq.id=subq2.id+1
JOIN ##TEMP_FLOAT_TABLE subq3 ON subq.id=subq3.id+2
JOIN ##TEMP_FLOAT_TABLE subq4 ON subq.id=subq4.id+3
*/


--create the large global temp tables utilized in step 2 of the OLTP db generation
SET NOCOUNT ON
Use Resellers2ndHandStuffOLTP

DROP TABLE IF EXISTS ##TEMP_ROWSET_CITIES
CREATE TABLE ##TEMP_ROWSET_CITIES
(
	id INT UNIQUE,
	city NVARCHAR(50)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_CITIES_INDEX
ON ##TEMP_ROWSET_CITIES(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_EMAILS
CREATE TABLE ##TEMP_ROWSET_EMAILS
(
	id INT UNIQUE,
	email NVARCHAR(75)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_EMAILS_INDEX
ON ##TEMP_ROWSET_EMAILS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_FLOATS_TINY
CREATE TABLE ##TEMP_ROWSET_FLOATS_TINY
(
	id INT UNIQUE,
	val FLOAT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_FLOATS_TINY_INDEX
ON ##TEMP_ROWSET_FLOATS_TINY(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_FLOATS_MED
CREATE TABLE ##TEMP_ROWSET_FLOATS_MED
(
	id INT UNIQUE,
	val FLOAT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_FLOATS_MED_INDEX
ON ##TEMP_ROWSET_FLOATS_MED(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_FLOATS_LARGE
CREATE TABLE ##TEMP_ROWSET_FLOATS_LARGE
(
	id INT UNIQUE,
	val FLOAT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_FLOATS_LARGE_INDEX
ON ##TEMP_ROWSET_FLOATS_LARGE(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_INTS_2_DIGITS
CREATE TABLE ##TEMP_ROWSET_INTS_2_DIGITS
(
	id INT UNIQUE,
	val INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_INTS_2_DIGITS_INDEX
ON ##TEMP_ROWSET_INTS_2_DIGITS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_INTS_3_DIGITS
CREATE TABLE ##TEMP_ROWSET_INTS_3_DIGITS
(
	id INT UNIQUE,
	val INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_INTS_3_DIGITS_INDEX
ON ##TEMP_ROWSET_INTS_3_DIGITS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_INTS_4_DIGITS
CREATE TABLE ##TEMP_ROWSET_INTS_4_DIGITS
(
	id INT UNIQUE,
	val INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_INTS_4_DIGITS_INDEX
ON ##TEMP_ROWSET_INTS_4_DIGITS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_ALL_UNIQUE_INTS
CREATE TABLE ##TEMP_ROWSET_ALL_UNIQUE_INTS
(
	id INT UNIQUE,
	val INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_ALL_UNIQUE_INTS_INDEX
ON ##TEMP_ROWSET_ALL_UNIQUE_INTS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_PHONE_NOS
CREATE TABLE ##TEMP_ROWSET_PHONE_NOS
(
	id INT UNIQUE,
	phone_no NVARCHAR(25),
	country_code NVARCHAR(5)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_PHONE_NOS_INDEX
ON ##TEMP_ROWSET_PHONE_NOS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_SINGLE_INTS
CREATE TABLE ##TEMP_ROWSET_SINGLE_INTS
(
	id INT UNIQUE,
	val INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_SINGLE_INTS_INDEX
ON ##TEMP_ROWSET_SINGLE_INTS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_STATES
CREATE TABLE ##TEMP_ROWSET_STATES
(
	id INT UNIQUE,
	state_val NVARCHAR(50)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_STATES_INDEX
ON ##TEMP_ROWSET_STATES(id)
WITH (MAXDOP = 1);

DROP TABLE IF EXISTS ##TEMP_ROWSET_TEMPWORDS
CREATE TABLE ##TEMP_ROWSET_TEMPWORDS
(
	id INT UNIQUE,
	val NVARCHAR(100)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_TEMPWORDS_INDEX
ON ##TEMP_ROWSET_TEMPWORDS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_ZIPS
CREATE TABLE ##TEMP_ROWSET_ZIPS
(
	id INT UNIQUE,
	zip_code INT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_ZIPS_INDEX
ON ##TEMP_ROWSET_ZIPS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_DATES
CREATE TABLE ##TEMP_ROWSET_DATES
(
	id INT UNIQUE,
	val DATE
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_DATES_INDEX
ON ##TEMP_ROWSET_DATES(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_DATETIMES
CREATE TABLE ##TEMP_ROWSET_DATETIMES
(
	id INT UNIQUE,
	val DATETIME
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_DATETIMES_INDEX
ON ##TEMP_ROWSET_DATETIMES(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_BOOLS
CREATE TABLE ##TEMP_ROWSET_BOOLS
(
	id INT UNIQUE,
	val BIT
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_BOOLS_INDEX
ON ##TEMP_ROWSET_BOOLS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_URLS
CREATE TABLE ##TEMP_ROWSET_URLS
(
	id INT UNIQUE,
	url NVARCHAR(256)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_URLS_INDEX
ON ##TEMP_ROWSET_URLS(id)
WITH (MAXDOP = 1);
SELECT COUNT(*) FROM ##TEMP_ROWSET_URLS

DROP TABLE IF EXISTS ##TEMP_ROWSET_BUDGET_CATGS
CREATE TABLE ##TEMP_ROWSET_BUDGET_CATGS
(
	id INT UNIQUE,
	val NVARCHAR(256)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_BUDGET_CATGS_INDEX
ON ##TEMP_ROWSET_BUDGET_CATGS(id)
WITH (MAXDOP = 1);
DROP TABLE IF EXISTS ##TEMP_ROWSET_KIND_OF_BUSINESS_CATGS
CREATE TABLE ##TEMP_ROWSET_KIND_OF_BUSINESS_CATGS
(
	id INT UNIQUE,
	val NVARCHAR(256)
)
CREATE CLUSTERED INDEX CI_TEMP_ROWSET_KIND_OF_BUSINESS_CATGS_INDEX
ON ##TEMP_ROWSET_KIND_OF_BUSINESS_CATGS(id)
WITH (MAXDOP = 1);
SELECT COUNT(*) FROM ##TEMP_ROWSET_KIND_OF_BUSINESS_CATGS

